package DP系列.状态压缩DP.优美的排列;

import java.util.Scanner;

/**
 * @Author: Jack
 * @Date: 2020/5/14 19:36
 * @Description: 状态压缩DP
 * 同样的，这道题也涉及到[1,N]数字是否被使用过的状态记录
 * @Url:
 * @限制:
 * @Level:
 */
public class Solution1 {

    public int countArrangement(int N) {
        /**
         * 使用dp[n]表示二进制数n代表的所有排列中有效情况的数量
         * 例如二进制数010101（i=21），第1,3,5位是1，一共3个1，所以表示1,3,5以任意顺序放在数组前3位。
         * 那么，对于二进制中为0的位，判断是否可以作为下一个放入数组中的数，若是则更新dp[n | (1 << j)] += dp[n]
         * 例如：
         * 010101中，第2位为0，判断其是否可放在数组第4位（因为数组已有3个数），显然可以（4%2==0），
         * 所以更新dp[010101 | (1 << (2-1))] += dp[010101]，即dp[010111] += dp[010101];
         * 这个更新的+=可以这样理解：+=的左方dp[010111]表示1,3,5,2以任意顺序放在数组前4位时所有排列中有效情况的数量
         * 包括了{第二位的2放在数组的第四位，前面三位是[1,3,5]} 的情况
         *
         * 所以，我们的dp数组长度应该定义为(N个1所代表的二进制的十进制表示)+1，+1是为了最大可以表示dp[N个1所代表的二进制的十进制表示]
         * 例如 N = 2, 那么长度为 1<<2=4，最大表示dp[3]，3即2个1(11)
         */
        int[] dp = new int[1 << N];
        for (int i = 0; i < N; i++)
            dp[1 << i] = 1;  //每个数都能放在数组第1位，即dp['1'],['10'],['100']...=1

        for (int n = 0; n < (1 << N); n++) { //填dp表,dp[n]表示二进制数n代表的所有排列中有效情况的数量,n范围[0,(1<<N)-1]
            //数n的二进制表示中1的个数为one，表示数组的前one位已有one个数字（哪个数字对应1在n的哪一位）
            //用来定位待确定数字的下一个位置,例如n=010101,由于题目中i从1开始,那么下一个待确定数字的下标为4即one+1
            int one = countOne(n);

            //遍历二进制位
            for (int step = 1; step <= N; step++){ //第step位
                //找到为0的位
                if ((n & (1 << (step-1))) == 0){ //如果数n的二进制表示的第step位为0（没有被选择）
                    //该位用来表示的数字为step,下一个待确定数字的位置为one(例如010101,one=3，那么数组下一个待确定数字的下标为3)
                    if (step % (one + 1) == 0 || (one+1) % step == 0)
                        dp[(1 << (step - 1)) | n] += dp[n];
                    /**
                     * (1 << step) | n
                     * 是将n的第step位变为1
                     * 如step=2,dp[010101 | (1 << (2-1))] += dp[010101]
                     * 1 << (2-1) = 1 << 1 = 10
                     * 然后
                     *  010101
                     * |000010
                     * =010111
                     */
                }
            }
        }
        return dp[(1 << N) - 1]; //数字(1<<N)-1值为(N个1的二进制表示的十进制数)，dp[(1<<N)-1]表示二进制数(1<<N)-1代表的所有排列中有效情况的数量
    }

    /**
     * 统计num转化为二进制数的1的位数
     * @param num
     * @return
     */
    private int countOne(int num){
        int cnt = 0;
        while (num != 0) {
            num &= (num - 1);
            cnt++;
        }
        return cnt;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
    }
}
