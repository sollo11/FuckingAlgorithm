package DP系列.概率型DP.新21点;import java.util.Scanner;
/**
 * @Author: Jack
 * @Date: 2020/6/18 00:14
 * @Description:
 * 在[1,w]内进行抽牌（每次放回），当抽的累积和sum>=K时，就获胜，停止抽取数字
 * 给定一个整数N，N>=K，求抽的累积和sum<=N 的概率。
 * 结合N>=K，那么sum<=N时，也就是sum<=N>=K，那么sum>=K，也就是获胜了
 * 所以题目要求的概率为P(sum<=N|sum>=K)即在sum>=K的情况下求sum<=N的概率
 * 根据贝叶斯公式：
 * P(sum<=N | sum>=K) = P(sum<=N && sum>=K) / P(sum>=K)。
 * 这样，我们只要分别求出 P(sum<=N && sum>=K) 和 P(sum>=K) 就可以了。
 * 点数大于 W 的时候，概率怎么算呢？
 * 比如 W = 10, 我们拿到 15 点的概率是多少呢？这时候肯定不止拿一张牌了，那么我们分析最后一张牌。
 * 可以取1到 10，那么能拿到 15 点就有十种情况，之前共拿 5 点且最后一张拿 10，之前共拿 6 点且最后一张拿 9，
 * 之前拿共 7 点且最后一张拿 8，...，之前共拿 14 点且最后一张拿 1（可见后一张牌范围是[1,10]）
 * 那么拿 15 点的概率就是把这十种的概率都加起来。
 * 这道题给的假设是每次取牌都是等概率的，不管什么时候拿到 [1, W] 内的任意张牌的概率都是 1/W。
 * 那么对于累积和为sum(sum>=W且sum<=K，因为小于等于W的点数概率都是 1/W，而大于等于 K 的时候，就不会再拿牌了)
 * 的概率就可以归纳出下面的等式：
 * P(sum) = 1/W * [P(sum-1) + P(sum-2) + P(sum-W)] = 1/W * sumP(sum-W, sum-1)。
 * sumP(sum-W, sum-1) 表示 [sum-W, sum-1] 区间内所有点数的概率总和。
 * 所以， 由P(sum<=N && sum>=K) = P(K)+P(K+1)+...+P(N)
 * 并且 P(sum>=K) = P(K)+...P(+∞) = P(K) + ... + P(K+W-1)
 * 需要注意的是当sum=K+W-1时，要结合最后2步来看，首先，
 * 只有在分数不超过 N 时才算获胜；其次，可以达到的最大分数为 K+W-1，即在最后一次抽取数字之前的分数为 K−1，
 * 并且最后一次抽到了W从而获胜停止抽取,所以当sum>=K+W时概率为0
 * 从上可知，我们要求一定范围内抽的累积和的概率总和，并且最大累积和为K+W-1，
 * 我们可以开一个K+W大小的一维数组sum[i],表示抽取累积和在[0,i]内的情况的概率总和
 * 从sum[]定义可以得到sum[0]=p(0)，即累积和为[0,0]的概率总和是累积和为0的概率
 * sum[i]=sum[i-1]+p(i)，即累积和为[0,i]的概率总和是累积和为[0,i-1]的概率总和加上累积和为i的概率
 * 对于状态转移方程，要根据抽取累积和与K,W的关系来作判断
 * 设P[i]为抽取累积和为i时的概率，以N=21, K=17, W=10为例:
 * ①当 i <= W 时：
 * 先来说一下当点数不超过 10 的更新方法，这个其实比较简单，比如拿到七点的概率 P[7]，根据我们上面对于 P(x) 的求法，
 * 我们知道可以拆分为下列多种情况：先拿到 6 点的概率 (P[6]) 乘以再拿一个 1 点的概率 (1/W)，
 * 先拿到 5 点的概率 (P[5]) 乘以再拿一个 2 点的概率 (1/W)，...，先拿到 1 点的概率 (P[1])
 * 乘以再拿一个 6 点的概率 (1/W)，直接拿个 7 点的概率 (1/W)，那么统统加起来，就是：
 * P[7] = 1/W * (P[6] + p[5] + ... + P[1] + P[0]) = 1/W * sum[6]。
 * 归纳一下，对于 i <= W 的情况下：
 * P[i] = 1/W * sum[i-1]
 * sum[i] = sum[i-1] + P[i] = sum[i-1] + sum[i-1] / W
 * 如果此时的K改为3
 * 当 i > K 时，比如 P[5] 的更新方法就有所不同了，为啥呢？这要分析 5 点是怎么得来的，由于超过了 3 点就不能再摸牌了，
 * 所以 5 点只能由所有有效情况组成：
 * 先拿到 0 点的概率 (P[0]) 再拿到一个 5 点的概率 (1/W)，先拿到 1 点的概率 (P[1]) 再拿到一个 4 点的概率 (1/W)，...，
 * 先拿到 2 点的概率 (P[2]) 再拿到一个 3 点的概率 (1/W)，先拿到3点时就已经停止了，所以后面都没用，那么统统加起来就是：
 * P[5] = 1/W * (P[1] + P[2] + P[3]) = 1/W * sum[3] = 1/W * (sum[K-1])
 * ②当 i > W 时
 * 比如要求得到 15 点的概率 P[15]，那么还是根据上面求 P(x) 的方法，拆分为下面多种情况：
 * 先拿到 14 点的概率 (P[14]) 乘以再拿一个 1 点的概率 (1/W)，先拿到 13 点的概率 (P[13]) 乘以再拿一个 2 点的概率 (1/W)，...，
 * 先拿到 5 点的概率 (P[5]) 乘以再拿一个 10 点的概率 (1/W)，那么统统加起来就是：
 * P[15] = 1/W * (P[14] + P[13] + ... + P[5]) = 1/W * (sum[14] - sum[4])。
 * 归纳一下，对于 i > W 的情况下：
 * P[i] = 1/W * (sum[i-1] - sum[i-W-1])
 * sum[i] = sum[i-1] + P[i] = sum[i-1] + (sum[i-1] - sum[i-W-1]) / W
 * 当 i > K 时，比如 P[20] 的更新方法就有所不同了，为啥呢？这要分析 20 点是怎么得来的，由于超过了 17 点就不能再摸牌了，
 * 所以 20 点只能由所有有效情况组成：
 * 先拿到 16 点的概率 (P[16]) 再拿到一个 4 点的概率 (1/W)，先拿到 15 点的概率 (P[15]) 再拿到一个 5 点的概率 (1/W)，...，
 * 先拿到 10 点的概率 (P[10]) 再拿到一个 10 点的概率 (1/W)，那么统统加起来就是：
 * P[20] = 1/W * (P[16] + P[15] + P[14] + ... + P[10]) = 1/W * (sum[16] - sum[9]) = 1/W * (sum[K-1]-sum[20-W-1])
 *
 * 总结一下：
 * P[i] = 1/W * sum[i-1]（i <=K && i <= W）
 * p[i] = 1/W * sum[K-1]（i > K  && i <= W）
 * P[i] = 1/W * (sum[i-1] - sum[i-W-1]) （i <= K && i > W）
 * P[i] = 1/W * (sum[K-1] - sum[i-W-1]) （i > K && i > W）
 * 由上可知，K 和 W 的大小关系其实是不知道的，不过我们可以把二者揉在一起，
 * 我们每次使用 i-1 和 K-1 中的较小值来算 P[i] 即可，这样就完美把 K 融到了 W 的分类情况中了。
 * 例如i<=K，那么i-1<=K-1，所以结果取较小值i-1
 * 当 sums 数组计算完成之后，我们就直接按照上面的条件概率公式来算就行了。
 * @Url: https://leetcode-cn.com/problems/new-21-game/
 * @限制: 
 * @Level: 
 */
public class Solution {

    public double new21Game(int N, int K, int W) {
        if (K == 0 || N >= K - 1 + W) //还没开始抽就停止了或者最后两轮，倒数第二轮累积和为K-1, 最后一轮抽最大数W还没有超过N
            return 1.0;
        double[] sum = new double[K + W];
        sum[0] = 1.0;
        for (int i = 1; i <= K + W - 1; i++) {
            int min = Math.min(i - 1, K - 1);
            if (i <= W) sum[i] = sum[i - 1] + sum[min] / W;
            else sum[i] = sum[i - 1] + (sum[min] - sum[i - W - 1]) / W;
        }
        /**
         * P(sum<=N && sum>=K) = P(K)+P(K+1)+...+P(N)
         * P(sum>=K) = P(K)+...P(+∞) = P(K) + ... + P(K+W-1)
         */
        return (sum[N] - sum[K - 1]) / (sum[K + W - 1] - sum[K - 1]);
    }
    public static void main(String[] args){
         Scanner scanner=new Scanner(System.in);
    }
}
